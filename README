A strong password generator using bcrypt for key derivation in a convenient toolbar.

Every few weeks we get to hear about some database full of passwords being stolen: ubuntu forums (1.8 million stolen passwords), macrumours (860,000 stolen passwords), adobe (150 million stolen passwords), linkedin (6.5 million stolen passwords), last.fm (2.5 million stolen passwords), eharmony (1.5 million stolen passwords), etc, etc.

Sadly, most of these passwords are poorly protected - often no salt is used at all. When a salt is used, half of the times the passwords are still hashed using a fast hashing algorithm such as md5. And then there's Adobe - encrypting passwords (reversibly) using 3DES. All it takes is for the hacker(s) to also have stolen the key to be able to immediately decrypt a wealth of passwords.

And that, really, is only the beginning. Every time passwords can be cracked and plain passwords are dumped it only strengthens attackers by providing a whole new set of rules, password lists, etc, to use to brute-force other databases.

Since as a user you can't do much about the password thefts themselves, you have to look at how you can prevent this affecting you. Ideally, you'd want to use a different password on every website, and make the password as long and as random as possible. That way, it'll take a long time to crack your password (if it is even computationally possible/reasonable) and when it is cracked, it doesn't affect any of your other passwords. But reality is we can't be bothered with remembering a zillion long, random, passwords.

Enter password managers - they generate and store random passwords in a local database, which is protected by your master password. That way you can use an actual random password on every website, but the downside is that you always have to carry that file containing all your encrypted passwords with you (or use some web service to sync it). If you happen to lose your password database you are pretty much screwed. Nothing wrong with that - it's just not my cup of tea.

BPasswd, on the other hand, is a password generator that will generate a strong password from a salt (some website-specific identifier, e.g. "gmail") and a master password. At the heart of BPasswd is the bcrypt algorithm, an algorithm designed to be computationally expensive. The resulting password is long, "looks" random (and has no obvious pattern) and is site-specific.

From a more theoretical perspective, the keys generated by bpasswd are not good cryptographic keys - the achilles heel of bpasswd is the fact that the salt input to the bcrypt derivation function is not random, but rather derived from a simple, known, ASCII text. However, bpasswd is not designed to generate strong cryptographic keys, but rather to simply generate good, unique, passwords. From a password perspective, the generated passwords are no worse than a completely random password.



## Firefox, Chrome and web

BPasswd2 is available as a Firefox addon, a Chrome extension and a simple website. BPasswd2 is the new version of the original BPasswd addon that has been available for over a year now. It is fully backwards compatible, but offers more advanced settings which allow you to define per-site/salt options.

The website version is pure HTML + JavaScript, so it runs on your browser only and never submits anything to any server. You can even simply download the HTML and JavaScript files and run them locally.

The derived password is generated from an input master password and a "salt" (usually the site's domain without the TLD). All three versions of BPasswd have a number of other settings that affect the generated password: "cost", "generation/mapping method" and "maximum password length". The first is described under the "How it works" section. The last one should be obvious - by default BPasswd generates 32-character (or 30-character if z85 is used) passwords, but some websites have password length limitations. This setting simply trims the password to whatever number of characters you tell it. The "generation/mapping method" option defines how the raw output of the bcrypt function is mapped back to ASCII characters:

 - base64: simple base64 encoding of the derived key, resulting in a password of length 32, using the characters: a-z A-Z 0-9 + /
 - conservative: same as base64, except the resulting password (also of length 32) only contains a-z, A-Z and 0-9 (no special characters).
 - z85: ZeroMQ Base-85 encoding[1], resulting in a password of length 30, using the characters: a-z A-Z 0-9 . - : + = ^ ! ? * ? & < > ( ) [ ] { } @ % $ #


The strongest passwords are the ones generated through the 'z85' mapping function, as they contain up to 85 different characters. However, some websites are really picky about which characters they allow in passwords, so 'base64' is the default and 'conservative' can be used for the pickiest of sites. 'base64' was the only mapping function supported and used in the first version of BPasswd.


The Firefox and Chrome version can additionally store these site/salt-specific settings (and synchronize them using firefox sync/chrome sync). That way you can for example store a setting for paypal, so it only ever generates passwords that are 20 characters long. Every time you generate a password for paypal, it'll automatically use the saved settings - and it'll let you know that it did, too.


## How it works

A derived password for a specific site (salt) is generated as follows:

 1) The 'salt' is hashed using HMAC-SHA-256 keyed with the SHA256-hashed 'password'.
 2) The input to bcrypt is this hashed salt, the original 'password' and the cost.
 3) The output of bcrypt is a derived key of exactly 192 bits (24 bytes). This output is mapped back to ASCII characters through the mapping function defined by the generation method input.


The 'cost' input to bcrypt defines the number of iterations of the algorithm. The higher this value, the more compute intensive the key derivation is. The actual number of iterations is 2^(cost), so increasing the 'cost' by 1 roughly doubles the time it takes to derive a key. BPasswd (and BPasswd2) use a default cost of '6', i.e. 64 iterations.


As mentioned earlier, the result of this process is not a strong crytopgrahic key due to the salt not being random. However, it is more than appropriate as a password.


[1]: http://rfc.zeromq.org/spec:32




The salt is hashed using HMAC keyed with the hashed password - this salt is then used, alongside with the provided master password, to generate the final key using bcrypt, an algorithm designed to be computationally 
expensive.

The keyed HMAC expansion for the salt prevents rainbow tables generated for a fixed salt - this way the salt provided to the derivation function(bcrypt) is also a function of the key.

Press 'F9' to get the toolbar to show - pressing F9 again, the toolbar will hide. Just type in your master password, a salt for a given page (e.g. "amazon" or "gmail"), click "derive key" and the derived key will be 
shown and also copied into the clipboard.







The salt is hashed using HMAC keyed with the hashed password - this salt is then used, alongside with the provided master password, to generate the final key using bcrypt, an algorithm designed to be computationally 
expensive.

The keyed HMAC expansion for the salt prevents rainbow tables generated for a fixed salt - this way the salt provided to the derivation function(bcrypt) is also a function of the key.

Press the toolbar button to see the poup. Just type in your master password, a salt for a given page (e.g. "amazon" or "gmail"), click "derive key" and the derived key will be 
shown and also copied into the clipboard.

